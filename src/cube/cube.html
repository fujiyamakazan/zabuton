<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/three@0.131.3/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.131.3/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.createjs.com/tweenjs-0.6.2.min.js"></script>

<script>

/*
 * オブジェクトクリックで操作可能とする
 */

$(function() {

	$("#command").focus();

	/* レンダラ */
	const width = 300;
	const height = 300;
	const renderer = new THREE.WebGLRenderer({
		canvas : document.querySelector('#canvasCube'),
		alpha : true
	});
	renderer.setSize(width, height);
	renderer.setPixelRatio(window.devicePixelRatio);

	/* シーン */
	const scene = new THREE.Scene();

	/* グリッド */
	var cube_size = 100;
	var grid_count = 10;
	var grid_size = grid_count * cube_size;
	var grid = new THREE.GridHelper(grid_size, grid_count);
	grid.material.color = new THREE.Color(0xaaaaaa);
	scene.add(grid);

	/* カメラ */
	const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
	const cameraX = 500;
	const cameraY = 500;
	const cameraZ = 1000;
	camera.position.set(cameraX, cameraY, cameraZ);
	camera.lookAt(new THREE.Vector3(0, 0, 0));

    /* マウスのドラッグアンドドロップによるカメラ操作 */
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    /* ガイド */
    const loader = new THREE.FontLoader();
    loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/fonts/helvetiker_regular.typeface.json', (font) => {
	    function CreateText(word, x, y, z){
	        const textGeometry = new THREE.TextGeometry(word, {
	            font: font,
	            size: 100,
	            height: 10,
	            });
	        const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
	        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
	        textMesh.position.set(x, y, z);
	        return textMesh;
	    }
	    scene.add(CreateText("U", 0, 400, 0));
	    scene.add(CreateText("F", 0, 0, 400));
	    scene.add(CreateText("L", -400, 0, 0));
	    scene.add(CreateText("R", 400, 0, 0));
	    scene.add(CreateText("B", 0, 0, -400));
	    scene.add(CreateText("D", 0, -400, 0));
    });

    /* ライト */
    const light1 = new THREE.DirectionalLight(0xFFFFFF);
    const light2 = new THREE.DirectionalLight(0xFFFFFF);
    light1.position.set(1, 1, 1);
    light2.position.set(-1, -1, -1); // ライトの方向
    scene.add(light1);
    scene.add(light2);
    $('#lightUp').on('click', function() {
        light1.intensity = 2; // 明るさ200%
        light2.intensity = 2; // 明るさ200%
    });
    $('#lightDown').on('click', function() {
        light1.intensity = 1;
        light2.intensity = 1;
    });

    /* キューブ用透過素材 */
    const basicMate = new THREE.MeshBasicMaterial({color : 0xFFFFFF});
    basicMate.opacity = 0.1; // 透過設定
    basicMate.transparent = true; // 透過設定
    basicMate.depthTest = false; // 透過設定

    /* キューブ(稼働部分) */
    const basicBox = new THREE.BoxGeometry(400, 400, 400);
    var cube = new THREE.Mesh(basicBox, basicMate);
    scene.add(cube);

    /* キューブ（固定部分）*/
    var cubeFix = new THREE.Mesh(basicBox, basicMate);
    scene.add(cubeFix);

	/* ピース */
	function createPiece(x, y, z) {
		var materials = [
	        new THREE.MeshLambertMaterial({color : 0x000000}), // R面
	        new THREE.MeshLambertMaterial({color : 0x000000}), // L面
	        new THREE.MeshLambertMaterial({color : 0x000000}), // U面
	        new THREE.MeshLambertMaterial({color : 0x000000}), // D面
	        new THREE.MeshLambertMaterial({color : 0x000000}), // F面
	        new THREE.MeshLambertMaterial({color : 0x000000}) // B面
	    ];
		if (x == 100) {
			materials[0] = new THREE.MeshLambertMaterial({color : 0xFF0000}); // R面赤
		}
        if (x == -100) {
            materials[1] = new THREE.MeshLambertMaterial({color : 0xF58220}); // L面橙
        }
        if (y == 100) {
            materials[2] = new THREE.MeshLambertMaterial({color : 0xFFD800}); // U面黄
        }
        if (y == -100) {
            materials[3] = new THREE.MeshLambertMaterial({color : 0xFFFFFF}); // D面白
        }
        if (z == 100) {
            materials[4] = new THREE.MeshLambertMaterial({color : 0x0000FF}); // F面青
        }
        if (z == -100) {
            materials[5] = new THREE.MeshLambertMaterial({color : 0x009944}); //  B面緑
        }

		var material = new THREE.MeshFaceMaterial(materials);
		var mesh = new THREE.Mesh(new THREE.BoxGeometry(95, 95, 95), material);
		mesh.position.set(x, y, z);
		return mesh;
	}
	var pieces = [];

	pieces.push(createPiece(-100, 100, -100)); // BUL
	pieces.push(createPiece(0, 100, -100)); // BU
	pieces.push(createPiece(100, 100, -100)); // BUR

	pieces.push(createPiece(-100, 0, -100)); // BL
	pieces.push(createPiece(0, 0, -100)); // B
	pieces.push(createPiece(100, 0, -100)); // BR

	pieces.push(createPiece(-100, -100, -100)); // BDL
	pieces.push(createPiece(0, -100, -100)); // BD
	pieces.push(createPiece(100, -100, -100)); // BDR

	pieces.push(createPiece(-100, 100, 0)); // UL
	pieces.push(createPiece(0, 100, 0)); // U
	pieces.push(createPiece(100, 100, 0)); // UR

	pieces.push(createPiece(-100, 0, 0)); // L
	pieces.push(createPiece(0, 0, 0));
	pieces.push(createPiece(100, 0, 0)); // R

	pieces.push(createPiece(-100, -100, 0)); // DL
	pieces.push(createPiece(0, -100, 0)); // D
	pieces.push(createPiece(100, -100, 0)); // DR

	pieces.push(createPiece(-100, 100, 100)); // FUL
	pieces.push(createPiece(0, 100, 100)); // FU
	pieces.push(createPiece(100, 100, 100)); // FUR

	pieces.push(createPiece(-100, 0, 100)); // FL
	pieces.push(createPiece(0, 0, 100)); // F
	pieces.push(createPiece(100, 0, 100)); // FR

	pieces.push(createPiece(-100, -100, 100)); // FDL
	pieces.push(createPiece(0, -100, 100)); // FD
	pieces.push(createPiece(100, -100, 100)); // FDR

	pieces.forEach(function(piece, index) {
		cubeFix.add(piece);
	});

    /* レンダリング */
    renderer.render(scene, camera);

	/* 回転関連定数 */
	const angle90 = Math.PI / -2; // 90度
	const step = 0.08; // アニメーション単位の移動量

	var cursor = 0;
	var command = "";
	var commandOption = "";
	var opDouble = false;
	var opPrime = false;

	function animate() {

		requestAnimationFrame(animate);

		$("#tmpCommand").text(command + commandOption);

		/* レンダリング */
		renderer.render(scene, camera);

		function getWorldEulerAngles(object) {
			const rotation = new THREE.Euler();
			object.getWorldQuaternion(rotation); // オブジェクトのワールド座標系での回転クォータニオンを取得
			return rotation.toVector3(); // オイラー角に変換
		}

		function round100(number) {
			return Math.round(number / 100) * 100;
		}

		function convert(piece, from, to){
			var worldPos = piece.getWorldPosition(new THREE.Vector3());

			var wPx = round100(worldPos.x);
			var wPy = round100(worldPos.y);
			var wPz = round100(worldPos.z);
			var worldRot = getWorldEulerAngles(piece);
			var wRx = worldRot.x;
			var wRy = worldRot.y;
			var wRz = worldRot.z;

			from.remove(piece);
			to.add(piece);

			piece.position.x = wPx;
			piece.position.y = wPy;
			piece.position.z = wPz;
			piece.rotation.x = wRx;
			piece.rotation.y = wRy;
			piece.rotation.z = wRz;
		}

		/* コマンドの読取り */
		if (command == ''){

			/* 1文字分のコマンドを取得する */
			var inputCommand = $("#command").val();
			if (inputCommand.length > 0) {
				command = inputCommand.charAt(0);

				/* オプション対応 */
				if (inputCommand.length > 1 && (inputCommand.charAt(1) === 'w' || inputCommand.charAt(1) === '\'')) {
					if (inputCommand.length > 2 && (inputCommand.charAt(2) === 'w' || inputCommand.charAt(2) === '\'')) {
						commandOption = inputCommand.charAt(1) + inputCommand.charAt(2);
					} else {
						commandOption = inputCommand.charAt(1);
					}
				} else {
					commandOption = "";
				}
				opDouble = commandOption.includes('w');
				opPrime = commandOption.includes('\'');

			}

			/* 視点リセット */
			if (command == '0') {
			    // 処理なし
			}

			/* X/X'/Y/Y'/Z/Z' */
			if (command === 'X' || command === 'Y' || command == 'Z' ) {
	            pieces.forEach(function(piece, index) {
	                convert(piece, cubeFix, cube);
	            });
			}

			/* R/R' */
			if (command === 'R') {
	            pieces.forEach(function(piece, index) {
	                if (piece.position.x === 100) {
	                    convert(piece, cubeFix, cube);
	                }
	                if (opDouble && piece.position.x === 0) { // 2層回し
	                	convert(piece, cubeFix, cube);
	                }
	            });
			}

            /* M/M' */
            if (command === 'M') {
                pieces.forEach(function(piece, index) {
                    if (piece.position.x === 0) {
                        convert(piece, cubeFix, cube);
                    }
                });
            }

			/* L/L' */
			if (command === 'L') {
	            pieces.forEach(function(piece, index) {
	                if (piece.position.x === -100) {
	                    convert(piece, cubeFix, cube);
	                }
	            });
			}

			/* U/U' */
			if (command === 'U') {
	            pieces.forEach(function(piece, index) {
	                if (piece.position.y === 100) {
	                    convert(piece, cubeFix, cube);
	                }
                    if (opDouble && piece.position.y === 0) { // 2層回し
                        convert(piece, cubeFix, cube);
                    }
	            });
			}

            /* E/E' */
            if (command === 'E') {
                pieces.forEach(function(piece, index) {
                    if (piece.position.y === 0) {
                        convert(piece, cubeFix, cube);
                    }
                });
            }

			/* D/D' */
			if (command === 'D') {
	            pieces.forEach(function(piece, index) {
	                if (piece.position.y === -100) {
	                    convert(piece, cubeFix, cube);
	                }
	            });
			}

			/* F/F' */
			if (command === 'F') {
	            pieces.forEach(function(piece, index) {
	                if (piece.position.z === 100) {
	                    convert(piece, cubeFix, cube);
	                }
                    if (opDouble && piece.position.z === 0) { // 2層回し
                        convert(piece, cubeFix, cube);
                    }
	            });
			}

            /* S/S' */
            if (command === 'S') {
                pieces.forEach(function(piece, index) {
                    if (piece.position.z == 0) {
                        convert(piece, cubeFix, cube);
                    }
                });
            }

			/* B/B' */
			if (command === 'B') {
	            pieces.forEach(function(piece, index) {
	                if (piece.position.z === -100) {
	                    convert(piece, cubeFix, cube);
	                }
	            });
			}

			/* 1文字分のコマンドを消す */
		    if (inputCommand.length > 0) {
		        var tmp = inputCommand.slice(1 + commandOption.length);
		        $("#command").val(tmp);
		    }
			return;
		}

		var hasNext = false;

        function workX(flg){
            var i = flg ? 1 : -1;
            var next = angle90 * (cursor + i);
            var tmp = cube.rotation.x;
            if (!flg && (tmp < next) || flg && (tmp > next)) {
                cube.rotation.x += (step * i * -1);
                return true; // つづきあり
            } else {
                cursor += i;
                cube.rotation.x = next;
                return false; // 終了
            }
        }

        function workY(flg){
              var i = flg ? 1 : -1;
              var next = angle90 * (cursor + i);
              var tmp = cube.rotation.y;
              if (!flg && (tmp < next) || flg && (tmp > next)) {
                  cube.rotation.y += (step * i * -1);
                  return true; // つづきあり
              } else {
                  cursor += i;
                  cube.rotation.y = next;
                  return false; // 終了
              }
        }

        function workZ(flg){
              var i = flg ? 1 : -1;
              var next = angle90 * (cursor + i);
              var tmp = cube.rotation.z;
              if (!flg && (tmp < next) || flg && (tmp > next)) {
                  cube.rotation.z += (step * i * -1);
                  return true; // つづきあり
              } else {
                  cursor += i;
                  cube.rotation.z = next;
                  return false; // 終了
              }
        }

		/* X軸回転(L/R) */
		if (command === 'X') {
			hasNext = workX(!opPrime);
		}
		/* Y軸回転(U/D) */
		if (command === 'Y') {
			hasNext = workY(!opPrime);
		}
		/* Z軸回転(F/B) */
		if (command === 'Z') {
			hasNext = workZ(!opPrime);
		}
		/* R */
		if (command === 'R') {
			hasNext = workX(!opPrime);
		}
		/* L/M */
		if (command === 'L' || command === 'M') {
			hasNext = workX(opPrime);
		}
		/* U */
		if (command === 'U') {
			hasNext = workY(!opPrime);
		}
		/* D/E */
		if (command === 'D' || command === 'E') {
			hasNext = workY(opPrime);
		}
		/* F */
		if (command === 'F') {
			hasNext = workZ(!opPrime);
		}
		/* B/S */
		if (command === 'B' || command === 'S') {
			hasNext = workZ(opPrime);
		}

		/* 視点リセット */
		if (command === '0') {
			camera.position.set(cameraX, cameraY, cameraZ);
			camera.lookAt(new THREE.Vector3(0, 0, 0));
		}

		if(command != "" && hasNext == false){

			command = ""; // コマンド初期化
			commandOption = "";
			opDouble = false;
			opPrime = false;

			pieces.forEach(function(piece, index) {
				convert(piece, cube, cubeFix);
			});

			cube.position.x = 0;
			cube.position.y = 0;
			cube.position.z = 0;
			cube.rotation.x = 0;
			cube.rotation.y = 0;
			cube.rotation.z = 0;

			cursor = 0;

			/* レンダリング */
			renderer.render(scene, camera);

		}
	} // animate
	animate();

	/* ショートカットキー制御 */
	$(window).keyup(function(e){
		if(e.keyCode === 82) { // R
			if(event.shiftKey) {
				$("#command").val($("#command").val() + "R'");
			} else {
				$("#command").val($("#command").val() + "R");
			}
		}
		/*
	      if(e.keyCode == 48){ // 0
	    	  $("#command").val("0");
	      }

	      if(e.keyCode == 37){ // ←
	    	  $("#command").val("Z");
	      }
             if(e.keyCode == 38){ // ↑
                 $("#command").val("x");
             }
	      if(e.keyCode == 39){ // →
	    	  $("#command").val("z");
	      }
	      if(e.keyCode == 40){ // ↓
                 $("#command").val("X");
             }

             if(e.keyCode == 100){ // テンキー4
                 $("#command").val("y");
             }
             if(e.keyCode == 102){ // テンキー6
                 $("#command").val("Y");
             }

             if(e.keyCode == 105){ // テンキー9
                 $("#command").val("r");
             }
             if(e.keyCode == 99){ // テンキー3
                 $("#command").val("R");
             }

             if(e.keyCode == 103){ // テンキー7
                 $("#command").val("L");
             }
             if(e.keyCode == 97){ // テンキー1
                 $("#command").val("l");
             }

             if(e.keyCode == 104){ // テンキー8
                 $("#command").val("u");
             }
             if(e.keyCode == 101){ // テンキー5
                 $("#command").val("U");
             }

             if(e.keyCode == 98){ // テンキー2
                 $("#command").val("D");
             }
             if(e.keyCode == 96){ // テンキー0
                 $("#command").val("d");
             }

             if(e.keyCode == 111){ // テンキー/
                 $("#command").val("f");
             }
             if(e.keyCode == 106){ // テンキー*
                 $("#command").val("F");
             }
		   */
	  });

});

function Shuffle(){
    const characters = 'rRlLuUdDfFbB';
    let randomString = '';
    for (let i = 0; i < 10; i++) {
        const randomIndex = Math.floor(Math.random() * characters.length);
        randomString += characters.charAt(randomIndex);
    }
    $("#command").val(randomString);
}
function SetCommand(cmd){
    $("#command").val(cmd);
}

</script>
</head>
<body style="background-color: black;">
    <button onclick="location.reload();">Reset</button>
    <button onclick="Shuffle();">Shuffle</button>
    <br>
    <button onclick="SetCommand('X');">X</button><button onclick="SetCommand('X\'');">X'</button>
    <button onclick="SetCommand('X');">Y</button><button onclick="SetCommand('X\'');">Y'</button>
    <button onclick="SetCommand('X');">Z</button><button onclick="SetCommand('X\'');">Z'</button>
    <br>
    <button onclick="SetCommand('R');">R</button><button onclick="SetCommand('R\'');">R'</button>
    <button onclick="SetCommand('M');">M</button><button onclick="SetCommand('M\'');">M'</button>
    <button onclick="SetCommand('L');">L</button><button onclick="SetCommand('L\'');">L'</button>
    <br>
    <button onclick="SetCommand('U');">U</button><button onclick="SetCommand('U\'');">U'</button>
    <button onclick="SetCommand('E');">E</button><button onclick="SetCommand('E\'');">E'</button>
    <button onclick="SetCommand('D');">D</button><button onclick="SetCommand('D\'');">D'</button>
    <br>
    <button onclick="SetCommand('F');">F</button><button onclick="SetCommand('F\'');">F'</button>
    <button onclick="SetCommand('S');">S</button><button onclick="SetCommand('S\'');">S'</button>
    <button onclick="SetCommand('B');">B</button><button onclick="SetCommand('B\'');">B'</button>
    <br>
    <button onclick="SetCommand('Rw');">Rw</button><button onclick="SetCommand('R\'w');">R'w</button>
    <button onclick="SetCommand('Uw');">Uw</button><button onclick="SetCommand('U\'w');">U'w</button>
    <button onclick="SetCommand('Fw');">Fw</button><button onclick="SetCommand('F\'w');">F'w</button>
    <br>
    <span style="background-color: white;">
       コマンドで指定：<span id="tmpCommand">X</span><input type="text" id="command" style="ime-mode: disabled" /><br>
    </span>
    <br>
    <button id="lightUp">💡+</button><button id="lightDown">💡-</button><br>
	<canvas id="canvasCube"></canvas>
</body>
</html>
