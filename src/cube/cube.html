<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/three@0.131.3/build/three.min.js"></script>
<script
	src="https://unpkg.com/three@0.131.3/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.createjs.com/tweenjs-0.6.2.min.js"></script>

<script>
	var materials = [ new THREE.MeshLambertMaterial({
		color : 0xff0000
	}), // R面赤
	new THREE.MeshLambertMaterial({
		color : 0xffa000
	}), // L面橙
	new THREE.MeshLambertMaterial({
		color : 0xffdc00
	}), // U面黄
	new THREE.MeshLambertMaterial({
		color : 0xffffff
	}), // D面白
	new THREE.MeshLambertMaterial({
		color : 0x0000ff
	}), // F面青
	new THREE.MeshLambertMaterial({
		color : 0x009944
	}) // B面緑
	];

	window.addEventListener('DOMContentLoaded', init);

	var existX = 0;
	var existY = 0;
	var existZ = 0;

	function init() {

		const width = 300;
		const height = 300;

		const renderer = new THREE.WebGLRenderer({
			canvas : document.querySelector('#canvasCube'),
			alpha : true
		});
		renderer.setSize(width, height);
		renderer.setPixelRatio(window.devicePixelRatio);

		const scene = new THREE.Scene();

		/* グリッド */
		var cube_size = 100;
		var grid_count = 10;
		var grid_size = grid_count * cube_size;
		var grid = new THREE.GridHelper(grid_size, grid_count);
		grid.material.color = new THREE.Color(0xaaaaaa);
		scene.add(grid);

		const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
		camera.position.set(500, 500, 1000); // カメラ初期座標 X,Y,Z
		//camera.lookAt(scene.position);

		function createPiece(p1, y, p3) {
			var material = new THREE.MeshFaceMaterial(materials);
			/*
			for (var i = 0; i < material.length; ++i) {
				var m = material[i];
				//alert(m);
				//m.opacity = OPACITY;
				//m.transparent = TRANSPARENT;
				//m.depthTest = DEPTH_TEST;
			}
			 */
			var mesh = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 100),
					material);
			mesh.position.set(p1, y, p3);
			return mesh;
		}

		//scene.add(createPiece(-100, 100, -100)); // BUL
		//scene.add(createPiece(0, 100, -100)); // BU
		//scene.add(createPiece(100, 100, -100)); // BUR

		//scene.add(createPiece(-100, 0, -100)); // BL
		//scene.add(createPiece(0, 0, -100)); // B
		var B = createPiece(0, 0, -100);
		//scene.add(createPiece(100, 0, -100)); // BR

		//scene.add(createPiece(-100, -100, -100)); // BDL
		//scene.add(createPiece(0, -100, -100)); // BD
		//scene.add(createPiece(100, -100, -100)); // BDR

		//scene.add(createPiece(-100, 100, 0)); // UL
		//scene.add(createPiece(0, 100, 0)); // U
		//scene.add(createPiece(100, 100, 0)); // UR

		//scene.add(createPiece(-100, 0, 0)); // L
		//scene.add(createPiece(0, 0, 0));
		//scene.add(createPiece(100, 0, 0)); // R

		//scene.add(createPiece(-100, -100, 0)); // DL
		//scene.add(createPiece(0, -100, 0)); // D
		//scene.add(createPiece(100, -100, 0)); // DR

		//scene.add(createPiece(-100, 100, 100)); // FUL
		//scene.add(createPiece(0, 100, 100)); // FU
		//scene.add(createPiece(100, 100, 100)); // FUR

		//scene.add(createPiece(-100, 0, 100)); // FL
		//scene.add(createPiece(0, 0, 100)); // F
		//scene.add(createPiece(100, 0, 100)); // FR

		//scene.add(createPiece(-100, -100, 100)); // FDL
		//scene.add(createPiece(0, -100, 100)); // FD
		//scene.add(createPiece(100, -100, 100)); // FDR
		var FDR = createPiece(100, -100, 100);
		//scene.add(FDR);

		//const mesh = new THREE.Mesh(new THREE.SphereGeometry(80, 30, 30), new THREE.MeshNormalMaterial());
		var cube = new THREE.Mesh(new THREE.BoxGeometry(300, 300, 300),
				new THREE.MeshBasicMaterial({
					color : 0xFFFFFF
				}));

		/* 透過 */
		cube.material.opacity = 0.2;
		cube.material.transparent = true;
		cube.material.depthTest = false;

		scene.add(cube);
		cube.add(FDR);
		cube.add(B);

		cube.remove(B);
		scene.add(B);

		// オイラー角
		//FDR.rotation.x += Math.PI/2 * -1; // 90度回転(x軸方向)

		/*
		// クォータニオン
		FDR.useQuaternion = true;
		//回転軸ベクトルの宣言・規格化
		var axis = new THREE.Vector3(1, 1, 1).normalize();
		//回転角度の指定(ラジアン)
		var angle = Math.PI / 4;
		//クォータニオンオブジェクトの宣言
		var q = new THREE.Quaternion();
		//回転軸と角度からクォータニオンを計算
		q.setFromAxisAngle(axis, angle);
		//直方体オブジェクトのquaternionプロパティに代入
		FDR.quaternion.copy(q);
		 */

		// 平行光源
		const light = new THREE.DirectionalLight(0xFFFFFF);
		const light2 = new THREE.DirectionalLight(0xFFFFFF);
		//light.intensity = 2; // 明るさ200%
		//light2.intensity = 2; // 明るさ200%
		light.position.set(100, 100, 100); // ライトの方向
		light2.position.set(-100, -100, -100); // ライトの方向
		scene.add(light);
		scene.add(light2);

		/* マウスのドラッグアンドドロップによるカメラ操作 */
		const controls = new THREE.OrbitControls(camera, renderer.domElement);


		/* 回転関連定数 */
		const angle90 = Math.PI / -2; // 90度
		const step = 0.05; // アニメーション単位の移動量

		function animate() {
			requestAnimationFrame(animate);

			function workX(flg){
				var i = flg ? 1 : -1;
			    var next = angle90 * (existX + i);
			    if (!flg && (cube.rotation.x < next) || flg && (cube.rotation.x > next)) {
			        cube.rotation.x += (step * i * -1);
			    } else {
			    	existX += i;
			        cube.rotation.x = next;
			        $("#command").val("");
			        $("#valX").text(cube.rotation.x);
				}
			}

			function workY(flg){
				  var i = flg ? 1 : -1;
				  var next = angle90 * (existY + i);
				  if (!flg && (cube.rotation.y < next) || flg && (cube.rotation.y > next)) {
					  cube.rotation.y += (step * i * -1);
				  } else {
					  existY += i;
					  cube.rotation.y = next;
					  $("#command").val("");
					  $("#valY").text(cube.rotation.y);
				  }
			}

			function workZ(flg){
				  var i = flg ? 1 : -1;
				  var next = angle90 * (existZ + i);
				  if (!flg && (cube.rotation.z < next)
						  || flg && (cube.rotation.z > next)) {
					  cube.rotation.z += (step * i * -1);
				  } else {
					  existZ += i;
					  cube.rotation.z = next;
					  $("#command").val("");
					  $("#valZ").text(cube.rotation.z);
				  }
			}

			/* X軸正回転(L'/R) */
			if ($("#command").val() == 'x') {
				workX(true);
			}
			/* X軸逆回転(L/R') */
			if ($("#command").val() == 'X') {
				workX(false);
			}

			/* Y軸正回転(U/D') */
			if ($("#command").val() == 'y') {
				workY(true);
			}
			/* Y軸逆回転(U'/D) */
			if ($("#command").val() == 'Y') {
				workY(false);
			}

			/* Z軸正回転(F/B') */
			if ($("#command").val() == 'z') {
				workZ(true);
			}
			/* Z軸逆回転(F'/B) */
			if ($("#command").val() == 'Z') {
				workZ(false);
			}

			/* レンダリング */
			renderer.render(scene, camera);

		} // animate
		animate();
	}

</script>
</head>
<body style="background-color: black;">
	<canvas id="canvasCube"></canvas>
	<input type="text" id="command" />
	<p style="background-color: white;">
		<span>X軸回転：</span><span id="valX"></span><br>
		<span>Y軸回転：</span><span id="valY"></span><br>
		<span>Z軸回転：</span><span id="valZ"></span><br>
	</p>

</body>
</html>
