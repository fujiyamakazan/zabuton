<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/three@0.131.3/build/three.min.js"></script>
<script
	src="https://unpkg.com/three@0.131.3/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.createjs.com/tweenjs-0.6.2.min.js"></script>

<script>
	var materials = [ new THREE.MeshLambertMaterial({
		color : 0xff0000
	}), // R面赤
	new THREE.MeshLambertMaterial({
		color : 0xffa000
	}), // L面橙
	new THREE.MeshLambertMaterial({
		color : 0xffdc00
	}), // U面黄
	new THREE.MeshLambertMaterial({
		color : 0xffffff
	}), // D面白
	new THREE.MeshLambertMaterial({
		color : 0x0000ff
	}), // F面青
	new THREE.MeshLambertMaterial({
		color : 0x009944
	}) // B面緑
	];

	window.addEventListener('DOMContentLoaded', init);

	var existX = 0;
	var existY = 0;
	var existZ = 0;
	var pieces = [];

	function init() {

		/* レンダラ */
		const width = 300;
		const height = 300;
		const renderer = new THREE.WebGLRenderer({
			canvas : document.querySelector('#canvasCube'),
			alpha : true
		});
		renderer.setSize(width, height);
		renderer.setPixelRatio(window.devicePixelRatio);

		/* シーン */
		const scene = new THREE.Scene();

		/* グリッド */
		var cube_size = 100;
		var grid_count = 10;
		var grid_size = grid_count * cube_size;
		var grid = new THREE.GridHelper(grid_size, grid_count);
		grid.material.color = new THREE.Color(0xaaaaaa);
		scene.add(grid);

		/* カメラ */
		const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
		camera.position.set(500, 500, 1000); // カメラ初期座標 X,Y,Z
		//camera.lookAt(scene.position);

		/* ピース */
		function createPiece(p1, y, p3) {
			var material = new THREE.MeshFaceMaterial(materials);
			/*
			for (var i = 0; i < material.length; ++i) {
				var m = material[i];
				//alert(m);
				//m.opacity = OPACITY;
				//m.transparent = TRANSPARENT;
				//m.depthTest = DEPTH_TEST;
			}
			 */
			var mesh = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 100),
					material);
			mesh.position.set(p1, y, p3);
			return mesh;
		}

		pieces.push(createPiece(-100, 100, -100)); // BUL
		pieces.push(createPiece(0, 100, -100)); // BU
		pieces.push(createPiece(100, 100, -100)); // BUR

		pieces.push(createPiece(-100, 0, -100)); // BL
		//pieces.add(createPiece(0, 0, -100)); // B
		var B = createPiece(0, 0, -100);
		pieces.push(B);
		pieces.push(createPiece(100, 0, -100)); // BR

		pieces.push(createPiece(-100, -100, -100)); // BDL
		pieces.push(createPiece(0, -100, -100)); // BD
		pieces.push(createPiece(100, -100, -100)); // BDR

		pieces.push(createPiece(-100, 100, 0)); // UL
		pieces.push(createPiece(0, 100, 0)); // U
		pieces.push(createPiece(100, 100, 0)); // UR

		pieces.push(createPiece(-100, 0, 0)); // L
		pieces.push(createPiece(0, 0, 0));
		pieces.push(createPiece(100, 0, 0)); // R

		pieces.push(createPiece(-100, -100, 0)); // DL
		pieces.push(createPiece(0, -100, 0)); // D
		pieces.push(createPiece(100, -100, 0)); // DR

		pieces.push(createPiece(-100, 100, 100)); // FUL
		pieces.push(createPiece(0, 100, 100)); // FU
		pieces.push(createPiece(100, 100, 100)); // FUR

		pieces.push(createPiece(-100, 0, 100)); // FL
		pieces.push(createPiece(0, 0, 100)); // F
		pieces.push(createPiece(100, 0, 100)); // FR

		pieces.push(createPiece(-100, -100, 100)); // FDL
		pieces.push(createPiece(0, -100, 100)); // FD
		//scene.add(createPiece(100, -100, 100)); // FDR
		var FDR = createPiece(100, -100, 100);
		pieces.push(FDR);
		//scene.add(FDR);

		/* キューブ */
		//const mesh = new THREE.Mesh(new THREE.SphereGeometry(80, 30, 30), new THREE.MeshNormalMaterial());
		var cube = new THREE.Mesh(new THREE.BoxGeometry(300, 300, 300),
				new THREE.MeshBasicMaterial({
					color : 0xFFFFFF
				}));
		cube.material.opacity = 0.2; // 透過設定
		cube.material.transparent = true; // 透過設定
		cube.material.depthTest = false; // 透過設定

		scene.add(cube);

		//cube.add(FDR);
		//cube.add(B);
		//cube.remove(B);
		//scene.add(B);

		pieces.forEach(function(piece, index) {
			scene.add(piece);
			//console.log(piece.position.x);
		});


		/* ライト */
		const light = new THREE.DirectionalLight(0xFFFFFF);
		const light2 = new THREE.DirectionalLight(0xFFFFFF);
		//light.intensity = 2; // 明るさ200%
		//light2.intensity = 2; // 明るさ200%
		light.position.set(100, 100, 100); // ライトの方向
		light2.position.set(-100, -100, -100); // ライトの方向
		scene.add(light);
		scene.add(light2);

		/* マウスのドラッグアンドドロップによるカメラ操作 */
		const controls = new THREE.OrbitControls(camera, renderer.domElement);


		/* 回転関連定数 */
		const angle90 = Math.PI / -2; // 90度
		const step = 0.08; // アニメーション単位の移動量

		function animate() {
			requestAnimationFrame(animate);

			function workX(flg){
				var i = flg ? 1 : -1;
			    var next = angle90 * (existX + i);
			    if (!flg && (cube.rotation.x < next) || flg && (cube.rotation.x > next)) {
			        cube.rotation.x += (step * i * -1);
			    } else {
			    	existX += i;
			        cube.rotation.x = next;
			        $("#command").val("");
			        $("#valX").text(cube.rotation.x);
				}
			}

			function workY(flg){
				  var i = flg ? 1 : -1;
				  var next = angle90 * (existY + i);
				  if (!flg && (cube.rotation.y < next) || flg && (cube.rotation.y > next)) {
					  cube.rotation.y += (step * i * -1);
				  } else {
					  existY += i;
					  cube.rotation.y = next;
					  $("#command").val("");
					  $("#valY").text(cube.rotation.y);
				  }
			}

			function workZ(flg){
				  var i = flg ? 1 : -1;
				  var next = angle90 * (existZ + i);
				  if (!flg && (cube.rotation.z < next)
						  || flg && (cube.rotation.z > next)) {
					  cube.rotation.z += (step * i * -1);
				  } else {
					  existZ += i;
					  cube.rotation.z = next;
					  $("#command").val("");
					  $("#valZ").text(cube.rotation.z);
				  }
			}

            function combineALL(){
                pieces.forEach(function(piece, index) {
                    cube.add(piece);
                    //scene.remove(piece);
                });
            }

            function combineR(){
                pieces.forEach(function(piece, index) {
                	//cube.remove(piece);
                	//scene.remove(piece);
                	if (piece.position.x == 100) {
                		cube.add(piece);
                	} else {
                		//cube.remove(piece);
                		scene.add(piece);
                	}
                });
            }

            function releaseALL(){
                pieces.forEach(function(piece, index) {
                	//scene.add(piece);
                	//cube.add(piece);
                });
            }

			/* X軸正回転(L'/R) */
			if ($("#command").val() == 'x') {
				combineALL();
				workX(true);
				releaseALL();
			}
			/* X軸逆回転(L/R') */
			if ($("#command").val() == 'X') {
				combineALL();
				workX(false);
				releaseALL();
			}

			/* Y軸正回転(U/D') */
			if ($("#command").val() == 'y') {
				combineALL();
				workY(true);
				releaseALL();
			}
			/* Y軸逆回転(U'/D) */
			if ($("#command").val() == 'Y') {
				combineALL();
				workY(false);
				releaseALL();
			}

			/* Z軸正回転(F/B') */
			if ($("#command").val() == 'z') {
				combineALL();
				workZ(true);
				releaseALL();
			}
			/* Z軸逆回転(F'/B) */
			if ($("#command").val() == 'Z') {
				combineALL();
				workZ(false);
				releaseALL();
			}

			/* R/R' */
			if ($("#command").val() == 'r') {
                combineR();
                workX(true);
                releaseALL();
            }
            /* X軸逆回転(L/R') */
            if ($("#command").val() == 'R') {
                combineR();
                workX(false);
                releaseALL();
            }


			/* レンダリング */
			renderer.render(scene, camera);

		} // animate
		animate();
	}

</script>
</head>
<body style="background-color: black;">
	<canvas id="canvasCube"></canvas>
	<input type="text" id="command" />
	<p style="background-color: white;">
		<span>X軸回転：</span><span id="valX"></span><br>
		<span>Y軸回転：</span><span id="valY"></span><br>
		<span>Z軸回転：</span><span id="valZ"></span><br>
	</p>

</body>
</html>
